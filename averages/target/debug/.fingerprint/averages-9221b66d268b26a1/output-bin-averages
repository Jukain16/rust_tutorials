{"message":"binary assignment operation `+=` cannot be applied to type `Vec<{integer}>`","code":{"code":"E0368","explanation":"A binary assignment operator like `+=` or `^=` was applied to a type that\ndoesn't support it.\n\nErroneous code example:\n\n```compile_fail,E0368\nlet mut x = 12f32; // error: binary operation `<<` cannot be applied to\n                   //        type `f32`\n\nx <<= 2;\n```\n\nTo fix this error, please check that this type implements this binary\noperation. Example:\n\n```\nlet mut x = 12u32; // the `u32` type does implement the `ShlAssign` trait\n\nx <<= 2; // ok!\n```\n\nIt is also possible to overload most operators for your own type by\nimplementing the `[OP]Assign` traits from `std::ops`.\n\nAnother problem you might be facing is this: suppose you've overloaded the `+`\noperator for some type `Foo` by implementing the `std::ops::Add` trait for\n`Foo`, but you find that using `+=` does not work, as in this example:\n\n```compile_fail,E0368\nuse std::ops::Add;\n\nstruct Foo(u32);\n\nimpl Add for Foo {\n    type Output = Foo;\n\n    fn add(self, rhs: Foo) -> Foo {\n        Foo(self.0 + rhs.0)\n    }\n}\n\nfn main() {\n    let mut x: Foo = Foo(5);\n    x += Foo(7); // error, `+= cannot be applied to the type `Foo`\n}\n```\n\nThis is because `AddAssign` is not automatically implemented, so you need to\nmanually implement it for your type.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":84,"byte_end":85,"line_start":4,"line_end":4,"column_start":8,"column_end":9,"is_primary":false,"text":[{"text":"       v += v;","highlight_start":8,"highlight_end":9}],"label":"cannot use `+=` on type `Vec<{integer}>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":84,"byte_end":90,"line_start":4,"line_end":4,"column_start":8,"column_end":14,"is_primary":true,"text":[{"text":"       v += v;","highlight_start":8,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0368]\u001b[0m\u001b[0m\u001b[1m: binary assignment operation `+=` cannot be applied to type `Vec<{integer}>`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:4:8\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m       v += v;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mcannot use `+=` on type `Vec<{integer}>`\u001b[0m\n\n"}
{"message":"cannot divide `Vec<{integer}>` by `{integer}`","code":{"code":"E0369","explanation":"A binary operation was attempted on a type which doesn't support it.\n\nErroneous code example:\n\n```compile_fail,E0369\nlet x = 12f32; // error: binary operation `<<` cannot be applied to\n               //        type `f32`\n\nx << 2;\n```\n\nTo fix this error, please check that this type implements this binary\noperation. Example:\n\n```\nlet x = 12u32; // the `u32` type does implement it:\n               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html\n\nx << 2; // ok!\n```\n\nIt is also possible to overload most operators for your own type by\nimplementing traits from `std::ops`.\n\nString concatenation appends the string on the right to the string on the\nleft and may require reallocation. This requires ownership of the string\non the left. If something should be added to a string literal, move the\nliteral to the heap by allocating it with `to_owned()` like in\n`\"Your text\".to_owned()`.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":111,"byte_end":112,"line_start":6,"line_end":6,"column_start":15,"column_end":16,"is_primary":false,"text":[{"text":"   let mean = v / 8;","highlight_start":15,"highlight_end":16}],"label":"Vec<{integer}>","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":115,"byte_end":116,"line_start":6,"line_end":6,"column_start":19,"column_end":20,"is_primary":false,"text":[{"text":"   let mean = v / 8;","highlight_start":19,"highlight_end":20}],"label":"{integer}","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":113,"byte_end":114,"line_start":6,"line_end":6,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"   let mean = v / 8;","highlight_start":17,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0369]\u001b[0m\u001b[0m\u001b[1m: cannot divide `Vec<{integer}>` by `{integer}`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:6:17\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m   let mean = v / 8;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m{integer}\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mVec<{integer}>\u001b[0m\n\n"}
{"message":"aborting due to 2 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 2 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0368, E0369.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0368, E0369.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0368`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0368`.\u001b[0m\n"}
